generator client {
  provider = "prisma-client-js"
  output   = "../client/node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model VerxioUser {
  id                String   @id @default(cuid())
  email             String   @unique
  verxioBalance     Float    @default(0)
  creatorAddress    String?
  /// @encrypted
  creatorPrivateKey String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations:  Links to transactions this user sent or received
  sentTransactions     VerxioTransaction[] @relation("SentTransactions")
  receivedTransactions VerxioTransaction[] @relation("ReceivedTransactions")
  apiKeys              ApiKey[]

  @@index([email])
  @@index([creatorAddress])
  @@map("verxio_users")
}

model VerxioTransaction {
  id          String   @id @default(cuid())
  fromUserId  String? // ID of user who sent (null if admin issued)
  toUserId    String // ID of user who received
  amount      Float
  description String?
  createdAt   DateTime @default(now())

  // Relations: These link the transaction to VerxioUser records
  // fromUser: Links to the VerxioUser who sent (optional because admin can issue)
  fromUser VerxioUser? @relation("SentTransactions", fields: [fromUserId], references: [id])
  // toUser: Links to the VerxioUser who received
  toUser   VerxioUser  @relation("ReceivedTransactions", fields: [toUserId], references: [id])

  @@index([fromUserId])
  @@index([toUserId])
  @@index([createdAt])
  @@map("verxio_transactions")
}

model ApiKey {
  id         String    @id @default(cuid())
  key        String    @unique
  userId     String
  name       String? // Optional name/description for the API key
  isActive   Boolean   @default(true)
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  user VerxioUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
  @@index([isActive])
  @@map("api_keys")
}

model LoyaltyProgram {
  id                 String   @id @default(cuid())
  creator            String
  programPublicKey   String
  /// @encrypted
  programSecretKey   String
  signature          String
  metadataUri        String?  // Store the metadata URI for reuse when issuing passes
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  authorityPublicKey String
  /// @encrypted
  authoritySecretKey String
  claimLinks         LoyaltyClaimLink[]

  @@index([creator])
  @@index([programPublicKey])
  @@map("loyalty_programs")
}

model LoyaltyProgramClaimStatus {
  id             String   @id @default(cuid())
  programAddress String   @unique
  claimEnabled   Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("loyalty_program_claim_status")
}

model LoyaltyPass {
  id                   String   @id @default(cuid())
  loyaltyProgramAddress String
  recipient            String
  loyaltyPassPublicKey String
  /// @encrypted
  loyaltyPassPrivateKey String
  signature            String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@index([loyaltyProgramAddress])
  @@index([recipient])
  @@index([loyaltyPassPublicKey])
  @@map("loyalty_passes")
}

model VoucherCollection {
  id                 String   @id @default(cuid())
  creator            String
  collectionPublicKey String
  /// @encrypted
  collectionSecretKey String
  signature          String
  metadataUri        String?  // Store the metadata URI for reuse when minting vouchers
  authorityPublicKey String
  /// @encrypted
  authoritySecretKey String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  vouchers           Voucher[]
  rewardLinks        RewardLink[]

  @@index([creator])
  @@index([collectionPublicKey])
  @@map("voucher_collections")
}

model Voucher {
  id                String   @id @default(cuid())
  collectionId      String
  recipient         String
  voucherPublicKey  String
  /// @encrypted
  voucherPrivateKey String
  signature         String
  worth             Float?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  collection        VoucherCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@index([collectionId])
  @@index([recipient])
  @@index([voucherPublicKey])
  @@map("vouchers")
}

model RewardLink {
  id                String   @id @default(cuid())
  creatorEmail      String
  creatorAddress    String
  collectionId      String
  collectionAddress String
  slug              String?  @unique // Deprecated: use claimCode instead
  claimCode         String?  @unique
  voucherType       String
  voucherName       String?
  description       String?
  voucherWorth      Float?
  valueSymbol       String?
  assetName         String?
  assetSymbol       String?
  tokenAddress      String?
  maxUses           Int?
  expiryDate        DateTime?
  transferable      Boolean  @default(false)
  conditions        String?
  metadataUri       String?
  merchantId        String?
  status            String   @default("active")
  voucherAddress    String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  collection VoucherCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@index([creatorEmail])
  @@index([creatorAddress])
  @@index([collectionId])
  @@index([collectionAddress])
  @@index([claimCode])
  @@map("reward_links")
}

model LoyaltyClaimLink {
  id                  String   @id @default(cuid())
  creatorEmail        String
  creatorAddress      String
  programId           String
  programAddress      String
  claimCode           String   @unique
  passName            String?
  organizationName    String?
  description         String?
  metadataUri         String?
  status              String   @default("active")
  loyaltyPassAddress  String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  program LoyaltyProgram @relation(fields: [programId], references: [id], onDelete: Cascade)

  @@index([creatorEmail])
  @@index([creatorAddress])
  @@index([programId])
  @@index([programAddress])
  @@index([claimCode])
  @@map("loyalty_claim_links")
}

model Deal {
  id                 String    @id @default(cuid())
  creatorEmail       String
  collectionName     String
  category           String?
  tradeable          Boolean   @default(true)
  quantity           Int
  quantityRemaining  Int
  worth              Float?
  currency           String?
  country            String?
  website            String?
  expiryDate         DateTime?
  dealType           String?
  conditions         String?
  collectionAddress  String
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@index([creatorEmail])
  @@index([collectionAddress])
  @@map("deals")
}

// Better Auth Models
model User {
  id            String     @id @default(cuid())
  name          String
  email         String     @unique
  emailVerified Boolean    @default(false)
  image         String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  sessions      Session[]
  accounts      Account[]
  workflows     Workflow[]

  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String    @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt

  @@map("verification")
}

model Workflow {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("workflows")
}
